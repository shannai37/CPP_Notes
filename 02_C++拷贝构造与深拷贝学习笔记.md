# C++ 拷贝构造函数、深拷贝、this指针 学习笔记

## 目录
1. [拷贝构造函数基础](#1-拷贝构造函数基础)
2. [浅拷贝与深拷贝](#2-浅拷贝与深拷贝)
3. [this指针详解](#3-this指针详解)
4. [常见问题解答](#4-常见问题解答)
5. [面试重点](#5-面试重点)

---

## 1. 拷贝构造函数基础

### 1.1 什么是拷贝构造函数？

拷贝构造函数是一种特殊的构造函数，用一个已存在的对象来初始化一个新对象。

**语法格式：**
```cpp
类名(类名& 对象名) {
    // 拷贝逻辑
}
```

**示例：**
```cpp
class Student {
public:
    Student(Student& stu);  // 拷贝构造函数
};
```

### 1.2 为什么参数必须是引用？

如果参数不是引用，会导致无限递归：

```cpp
// 错误写法
Student(Student stu) {  // 传参时需要拷贝stu → 调用拷贝构造 → 又需要传参 → 无限递归
}

// 正确写法
Student(const Student& stu) {  // 引用不产生拷贝
}
```

### 1.3 为什么参数要加const？

**重要规则：临时对象（比如函数返回值）只能绑定到const引用**

```cpp
Student createStudent() {
    Student temp(1001, "张三");
    return temp;  // 返回临时对象
}

// 使用时
Student stu = createStudent();  // createStudent()返回临时对象
```

**如果拷贝构造参数不是const：**
```cpp
Student(Student& stu);  // 非const引用

Student stu = createStudent();  // 编译错误！临时对象不能绑定到非const引用
```

**正确写法：**
```cpp
Student(const Student& stu);  // const引用

Student stu = createStudent();  // 正确！const引用可以绑定临时对象
```

**总结：**
- 普通引用 `Student&` 只能绑定普通对象（左值）
- const引用 `const Student&` 可以绑定普通对象和临时对象（左值和右值）
- 拷贝构造函数必须用const引用，才能接受函数返回值

### 1.4 C++有默认的拷贝构造吗？

**有！** 如果不写拷贝构造函数，编译器会自动生成一个默认的。

**默认拷贝构造的行为：** 逐个成员拷贝（浅拷贝）

```cpp
// 编译器生成的默认版本相当于：
Student(const Student& stu) {
    this->stuID = stu.stuID;        // 拷贝int成员
    this->stuName = stu.stuName;    // 拷贝指针成员（只拷贝指针的值！）
}
```

### 1.5 拷贝构造函数的调用时机

拷贝构造函数在以下三种情况下自动调用：

**情况1：用对象初始化另一个对象**
```cpp
Student stu1(1001, "张三");
Student stu2 = stu1;  // 调用拷贝构造
Student stu3(stu1);   // 也是调用拷贝构造
```

**情况2：函数参数按值传递**
```cpp
void printStudent(Student s) {  // 参数是Student，不是Student&
    cout << s.getStuID() << endl;
}

Student stu1(1001, "张三");
printStudent(stu1);  // 传参时调用拷贝构造
```

**情况3：函数返回对象**
```cpp
Student createStudent() {
    Student s(1001, "张三");
    return s;  // 返回时理论上调用拷贝构造（编译器可能优化）
}
```

---

## 2. 浅拷贝与深拷贝

### 2.1 什么是浅拷贝？

浅拷贝只拷贝成员变量的值，对于指针成员，只拷贝指针本身（地址），不拷贝指针指向的内容。

**浅拷贝示例：**
```cpp
Student::Student(const Student& stu) {
    this->stuID = stu.stuID;        // 拷贝int，没问题
    this->stuName = stu.stuName;    // 只拷贝指针的值（地址）
}
```

**内存示意图：**
```
浅拷贝后：
  stu1.stuName (0x1000) ──┐
                          ├──→ 堆内存: "张三"
  stu2.stuName (0x1000) ──┘    (同一块内存！)
```

### 2.2 浅拷贝的问题

**问题1：内存共享**
- 两个对象的指针指向同一块内存
- 修改一个对象会影响另一个对象

**问题2：Double Free（程序崩溃）**
- stu2销毁时，释放内存（delete[] stuName）
- stu1销毁时，再次释放同一块内存
- 程序崩溃！

### 2.3 什么是深拷贝？

深拷贝不仅拷贝成员变量的值，还为指针成员重新分配内存，然后拷贝指针指向的内容。

**深拷贝三步走：**
1. 拷贝普通成员变量
2. 为指针成员重新分配内存
3. 拷贝指针指向的内容

**深拷贝示例：**
```cpp
Student::Student(const Student& stu) {
    // 第1步：拷贝普通成员
    this->stuID = stu.stuID;

    // 第2步：为指针成员重新分配内存（核心！）
    this->stuName = new char[strlen(stu.stuName) + 1];

    // 第3步：拷贝指针指向的内容
    strcpy(this->stuName, stu.stuName);
}
```

**内存示意图：**
```
深拷贝后：
  stu1.stuName (0x1000) ────→ 堆内存A: "张三"
  stu2.stuName (0x2000) ────→ 堆内存B: "张三"
                                (独立的内存！)
```

### 2.4 浅拷贝 vs 深拷贝对比

| 对比项 | 浅拷贝 | 深拷贝 |
|--------|--------|--------|
| 拷贝方式 | 只拷贝成员变量的值 | 拷贝成员变量，并为指针重新分配内存 |
| 指针成员 | 拷贝指针的值（地址） | 重新分配内存，拷贝内容 |
| 内存独立性 | 共享同一块内存 | 各自独立的内存 |
| 修改影响 | 修改一个会影响另一个 | 互不影响 |
| 析构问题 | Double Free 崩溃 | 各自释放，安全 |
| 何时使用 | 只有普通成员变量时 | 有指针、动态内存时 |

---

## 3. this指针详解

### 3.1 什么是this指针？

this是一个隐藏的指针，指向当前对象本身。

**特点：**
- 自动存在，不需要声明
- 指向当前对象
- 类型：`Student*`（指向Student的指针）
- 存储位置：栈上（作为隐藏参数传递）

### 3.2 为什么需要this指针？

**主要用途：区分成员变量和参数**

```cpp
class Student {
private:
    int stuID;
    
public:
    void setStuID(int stuID) {
        stuID = stuID;  // 错误！参数赋值给参数自己
    }
};
```

**正确写法：**
```cpp
void setStuID(int stuID) {
    this->stuID = stuID;  // 明确区分
    //   ↑          ↑
    //   成员变量    参数
}
```

### 3.3 this指针的常见用法

**用法1：区分成员变量和参数**
```cpp
Student::Student(int stuID, const char* stuName) {
    this->stuID = stuID;
    this->stuName = new char[strlen(stuName) + 1];
    strcpy(this->stuName, stuName);
}
```

**用法2：返回对象自身（链式调用）**
```cpp
Student& setStuID(int id) {
    this->stuID = id;
    return *this;  // 返回对象自身
}

// 使用：
stu.setStuID(1001).setStuName("张三");
```

**用法3：判断自赋值**
```cpp
Student& operator=(const Student& other) {
    if (this == &other) {  // 判断是否自己赋值给自己
        return *this;
    }
    // 执行赋值操作...
    return *this;
}
```

### 3.4 this指针的内存模型

```cpp
Student stu1(1001, "张三");
stu1.setStuID(2002);
```

**内存状态：**
```
栈内存：
┌─────────────────────────────┐
│  stu1 (地址: 0x6ffe00)      │
│  ┌──────────────────────┐   │
│  │ stuID: 1001          │   │
│  │ stuName: 0x1000      │   │
│  └──────────────────────┘   │
└─────────────────────────────┘

调用 stu1.setStuID(2002) 时：
┌─────────────────────────────┐
│  setStuID 函数栈帧          │
│  ┌──────────────────────┐   │
│  │ this = 0x6ffe00 ─────┼───┼──→ 指向stu1
│  │ stuID = 2002 (参数)  │   │
│  └──────────────────────┘   │
└─────────────────────────────┘
```

---

## 4. 常见问题解答

### 4.1 转义字符 `\"` 是什么？

`\"` 是转义字符，表示在字符串里输出一个双引号。

**示例：**
```cpp
cout << "释放 \"张三\" 的内存" << endl;
// 输出：释放 "张三" 的内存
```

**常见转义字符：**
- `\"` - 双引号
- `\'` - 单引号
- `\\` - 反斜杠
- `\n` - 换行
- `\t` - 制表符(Tab)

### 4.2 `delete` vs `delete[]` 的区别

**规则：用什么new，就用什么delete**

```cpp
// 单个对象
int* p = new int;
delete p;  // 正确

// 数组
int* arr = new int[10];
delete[] arr;  // 正确
```

**混用的后果：**
- 未定义行为
- 可能内存泄漏
- 可能程序崩溃

### 4.3 `(void*)this` 是什么意思？

```cpp
cout << "对象地址=" << (void*)this << endl;
//                    ↑      ↑
//                    │      └─ this指针（指向当前对象）
//                    └──────── 转换成void*类型
```

**解释：**
- `this` 是指向当前对象的指针
- `(void*)` 是类型转换，让cout能输出地址
- 用来打印对象的内存地址

**示例：**
```cpp
Student stu1(1001, "张三");
stu1.print();  // 输出：对象地址=0x6ffe00
```

### 4.4 为什么 `strlen()` 要 `+1`？

```cpp
this->stuName = new char[strlen(stuName) + 1];
```

**解释：**
- `strlen()` 计算字符串长度，但不包括结尾的 `\0`
- C风格字符串必须以 `\0` 结尾
- 所以要 `+1` 给 `\0` 留位置

**示例：**
```cpp
char* name = "张三";
strlen(name);  // 返回6（UTF-8编码，每个中文3字节）
// 实际需要7个字节：['张', '三', '\0']
```

---

## 5. 面试重点

### 5.1 拷贝构造函数相关

**问：什么是拷贝构造函数？**
- 用一个已存在的对象初始化一个新对象的特殊构造函数
- 参数必须是引用类型

**问：拷贝构造函数什么时候被调用？**
- 用对象初始化另一个对象
- 函数参数按值传递
- 函数返回对象

**问：如果不写拷贝构造函数会怎样？**
- 编译器自动生成默认的拷贝构造函数
- 默认执行浅拷贝
- 对于有指针成员的类，浅拷贝会导致问题

**问：类类型指针变量、类类型引用变量 会不会触发拷贝构造？**

​	**会触发拷贝构造的情况**

```c++
class MyClass {
public:
    MyClass() {
        cout << "默认构造函数" << endl;
    }
    
    MyClass(const MyClass& other) {
        cout << "拷贝构造函数" << endl;
    }
};

int main() {
    MyClass obj1;           // 默认构造函数
    
    // 会触发拷贝构造的情况：
    MyClass obj2 = obj1;    // 拷贝构造函数
    MyClass obj3(obj1);     // 拷贝构造函数
    
    return 0;
}
```

​	**类类型指针变量**

​	**不会触发拷贝构造** - 指针只是复制地址

```c++
int main() {
    MyClass obj1;           // 默认构造函数
    
    MyClass* ptr1 = &obj1;  // 不会触发拷贝构造 - 只创建了一个指针变量，复制地址，并不是创建对象！
    MyClass* ptr2 = ptr1;   // 不会触发拷贝构造 - 指针赋值
    
    return 0;
}
```

​	**类类型引用变量**

​	**不会触发拷贝构造** - 引用是别名

```c++
int main() {
    MyClass obj1;           // 默认构造函数
    
    MyClass& ref1 = obj1;   // 不会触发拷贝构造 - 引用是别名
    MyClass& ref2 = ref1;   // 不会触发拷贝构造
    
    return 0;
}
```

​	**核心原则：拷贝构造函数只有在 用已存在的对象  初始化    一个新对象时  才会触发，指针和引用操作不会创建新对象，因此不会触发拷贝构造。   指针和引用只是对现有对象的访问方式。**



### 5.2 浅拷贝与深拷贝相关

**问：浅拷贝和深拷贝的区别？**
- 浅拷贝：只拷贝指针的值，共享内存
- 深拷贝：重新分配内存，独立数据

**问：深拷贝应该要在什么场景下使用？**
1、类的成员变量存在指针类型数据

2、普通变量做为函数参数，实现函数类类型值传递

满足以上两个条件，深拷贝构造必须写

**问：如何实现深拷贝？**

- 深拷贝三步走：
  1. 拷贝普通成员
  2. 为指针成员重新分配内存
  3. 拷贝指针指向的内容



### 5.3 this指针相关

**问：什么是this指针？**
- 隐藏的指针，指向当前对象
- 类型：`Student*`（指向Student的指针）
- 存储位置：栈上

**问：this指针的作用？**
- 区分成员变量和参数
- 返回对象自身
- 判断自赋值

**问：static成员函数有this指针吗？**
- 没有！static成员函数不属于任何对象

### 5.4 企业开发规范

**Rule of Three（三法则）：**
如果需要自定义以下三个函数中的一个，通常三个都要自定义：
1. 析构函数
2. 拷贝构造函数
3. 赋值运算符

**代码规范：**
- 有指针成员，必须写拷贝构造（深拷贝）
- 有指针成员，必须写析构函数
- 所有成员变量访问用this

**现代C++建议：**
- 优先使用智能指针（shared_ptr、unique_ptr）
- 遵循Rule of Five（C++11）
- 使用移动语义（move constructor）
- 使用RAII（资源获取即初始化）

---

## 附录：完整代码示例

### Student.h
```cpp
#ifndef STUDENT_H
#define STUDENT_H

#include <iostream>
#include <cstring>
using namespace std;

class Student {
private:
    int stuID;
    char* stuName;

public:
    Student(int stuID, const char* stuName);
    Student(const Student& stu);  // 拷贝构造函数
    ~Student();

    int getStuID();
    char* getStuName();
    void setStuID(int stuID);
    void setStuName(const char* stuName);
    void print();
};

#endif
```

### 深拷贝构造函数实现
```cpp
Student::Student(const Student& stu) {
    // 第1步：拷贝普通成员
    this->stuID = stu.stuID;

    // 第2步：为指针成员重新分配内存
    this->stuName = new char[strlen(stu.stuName) + 1];

    // 第3步：拷贝指针指向的内容
    strcpy(this->stuName, stu.stuName);
}
```

### 析构函数实现
```cpp
Student::~Student() {
    delete[] this->stuName;  // 用new[]分配，必须用delete[]释放
    this->stuName = nullptr;
}
```

---

**学习建议：**
1. 理解拷贝构造的三种调用时机
2. 掌握深拷贝的三步走
3. 熟练使用this指针
4. 记住Rule of Three
5. 多写代码，多调试，观察内存变化

