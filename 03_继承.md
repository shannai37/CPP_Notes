## 一、初学继承

基础写法

```c++
#ifndef CHILD_H
#define CHILD_H

#include "Father.h"
using namespace std;

// Child 类 继承 Father 类，继承方式是public公有继承
class Child : public Father  // 这里应该是单个冒号，不是双冒号
{
public:
    Child();
    ~Child();
    void ChildFunction();	
};

#endif
```

**区别说明：**

- **`:`** (单个冒号)：用于类继承声明
- **`::`** (双冒号)：用于作用域解析（如 `std::cout`）

### 1.为什么子类能用父类的函数？

继承底层原理：
![image-20251113210749731](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251113210749731.png)

派生类（子类） 内存空间中除自己的数据成员和函数成员外，还有一块 基类（父类），里面有父类的数据成员和函数成员，所以子类既可以调用子类的数据成员和函数成员，也可以调用父类的数据成员和函数成员。



### 2.能否调用私有、受保护的数据成员和函数成员？

回顾我们01_初入C++ 中的权限控制

```c++
7. 访问控制

- public：公开的，任何地方都能访问

- private：私有的，只能在类内部（自己的成员函数）访问

- protected：保护的，类内部（自己的成员函数）和子类内部（子类的成员函数）可以访问
```

综上所述：
如果需要使用继承特性，父类成员变量和成员函数会设计权限为public或protected

只有这样子类才可以继承使用，但又因为封装强调成员变量的封装性，不建议使用public

所以得到结论父类成员变量大多数设计成protected



### 3.父类构造函数有参数，子类构造函数无参，继承失败？

我们前面说了，子类能用父类的函数的原因，正是因为 **子类的内存空间中含有基类（父类），里面有基类的数据成员和函数成员。**

而如果父类只有带参数的构造函数，子类必须显式调用它，否则**编译会报错**。

**问题原因**

在C++中：

1. **子类对象创建时，会先自动调用父类的构造函数**
2. 如果父类没有无参构造函数（或默认构造函数），编译器无法自动调用
3. 子类必须使用**初始化列表**显式调用父类的带参构造函数

**正确解决方案**

方案1：使用初始化列表调用父类构造函数（传递固定值）

```c++
class Child : public Parent {
public:
    // 使用初始化列表调用父类构造函数
    Child() : Parent(0) {  
        // 子类构造函数体
    }
};
```

方案2：子类接收参数并传递给父类

```c++
class Child : public Parent {
public:
    // 接收参数并传递给父类
    Child(int x) : Parent(x) {  
        // 子类构造函数体
    }
};
```

方案3：子类有多个构造函数

```c++
class Child : public Parent {
public:
    // 无参构造函数，传递默认值给父类
    Child() : Parent(0) {
    }
    
    // 带参构造函数，传递参数给父类
    Child(int x) : Parent(x) {
    }
    
    // 带多个参数的构造函数
    Child(int x, int y) : Parent(x) {
        // y 用于子类自己的初始化
    }
};
```

方案4：在父类中添加无参构造函数

```c++
class Parent {
public:
    Parent() {  // 添加无参构造函数
        // 默认初始化
    }
    
    Parent(int x) {
        // 带参数的初始化
    }
};

class Child : public Parent {
public:
    // 现在可以了，会自动调用父类的无参构造函数
    Child() 
    {  
        
    }
};
```

**总结**

- **问题**：父类只有带参构造函数时，子类无法编译通过
- **解决**：使用初始化列表 `: Parent(参数)` 显式调用父类构造函数  
- 初始化列表的作用是**把子类接收到的参数传给父类** 
- 父类构造函数用这些参数**初始化父类的成员变量**

```
你在 main.cpp 中传入的具体值
    ↓
子类构造函数接收这些值作为参数
    ↓
子类通过初始化列表把这些参数传给父类构造函数
    ↓
父类构造函数用这些参数初始化父类的成员变量
```



- **语法**：`Child() : Parent(参数) { }`

**子类对象包含父类部分,父类部分需要父类构造函数来初始化。如果不调用,父类成员就是垃圾值,程序就会出错!**



### 4.继承方式



![image-20251115160936682](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20251115160936682.png)







## 二、总结： 重载、重定义、重写 + 多态

### 1.重载

**定义**: 同一个作用域内，函数名相同，参数不同

**关键**:

- ✅ 函数名相同
- ✅ 参数列表不同（个数、类型、顺序）
- ✅ 可以在同一个类中
- ❌ 返回值不能作为重载的区分

```C++
class Father {
public:
    void show();           // 无参
    void show(int x);      // 一个int参数
    void show(int x, int y); // 两个int参数
};
```

**特点**: 编译时根据参数决定调用哪个



### 2.重定义

**定义**: 子类定义了和父类**同名**的函数（参数可以不同）

**关键**:

- ✅ 必须有继承关系
- ✅ 函数名相同
- ✅ 参数可以相同，也可以不同
- ❌ 不需要virtual
- ⚠️ 子类的函数会**隐藏**父类的所有同名函数

```c++
class Father {
public:
    void show() { cout << "Father" << endl; }
};

class Child : public Father {
public:
    void show() { cout << "Child" << endl; }  // 重定义
};

// 测试
Child c;
c.show();  // 输出: Child （子类的版本）
```

**特点**: 子类覆盖父类的同名函数



### 3.重写

**定义**: 子类重写父类的**虚函数**

**关键**:

- ✅ 必须有继承关系
- ✅ 父类函数必须是`virtual`
- ✅ 函数名、参数列表、返回值必须完全相同
- ✅ 实现多态的基础

```c++
class Father {
public:
    virtual void show() { cout << "Father" << endl; }
};

class Child : public Father {
public:
    void show() { cout << "Child" << endl; }  // 重写虚函数
};

// 测试
Father* p = new Child();
p->show();  // 输出: Child （多态！）
```



### 4.静态绑定 vs 动态绑定

#### 静态绑定（早绑定）

- **时机**: 编译时决定
- **依据**: 看指针/引用的**类型**
- **场景**: 普通函数、重载、重定义

```c++
Father* p = new Child();
p->show();  // 没有virtual，调用Father::show()
```



#### 动态绑定（晚绑定）

- **时机**: 运行时决定
- **依据**: 看实际对象的**类型**
- **场景**: 虚函数、多态

```c++
Father* p = new Child();
p->show();  // 有virtual，调用Child::show()
```



### 5.多态

**定义**

**同一个函数调用，根据实际对象类型，产生不同的行为**

#### 多态的三个必要条件 ⭐

1. **有继承关系** - 父类和子类
2. **有虚函数** - 父类用`virtual`声明
3. **父类指针/引用指向子类对象**

```c++
// 1. 有继承关系
class Father {
public:
    // 2. 有虚函数
    virtual void show() {  
        cout << "Father" << endl;
    }
};

class Child : public Father {
public:
    void show() {  // 重写虚函数
        cout << "Child" << endl;
    }
};

// 3. 父类指针指向子类对象
Father* p1 = new Father();
Father* p2 = new Child();

p1->show();  // 输出: Father
p2->show();  // 输出: Child  ← 多态！
```

#### 多态的应用

```c++
void test(Father* p) {
    p->show();  // 根据实际对象，自动调用正确版本
}

Father f;
Child c;
test(&f);  // 输出: Father
test(&c);  // 输出: Child  ← 一个函数，多种行为
```



## 三、纯虚函数 + 抽象类

### 1.纯虚函数

**定义**

在虚函数声明后加 `= 0`，表示这个函数**没有实现**，必须由子类实现

**语法对比**

```c++
// 普通虚函数
class Father {
public:
    virtual void show() 
    {  
        // 有实现
        cout << "Father的show" << endl;
    }
};
————————————————————————————————————————
// 纯虚函数
class Father {
public:
    virtual void show() = 0;  // 没有实现，加 = 0
};
```

### 2.抽象类

**定义**

- 包含**至少一个纯虚函数**的类就是抽象类
- 抽象类**不能实例化**（不能创建对象）
- 抽象类只能用来做**父类**

```c++
// 抽象类 - 有纯虚函数
class Father {
public:
    virtual void show() = 0;  // 纯虚函数
    virtual void work() = 0;  // 纯虚函数
    
    void FatherFunction() {   // 普通函数，可以有实现
        cout << "父类的普通函数" << endl;
    }
};

// ❌ 错误：抽象类不能实例化
Father f;  // 编译错误！

// ❌ 错误：抽象类不能new
Father* p = new Father();  // 编译错误！
```

### 3.子类的约束

**规则**

子类**必须实现**父类的所有纯虚函数，否则子类也是抽象类

```c++
// 父类 - 抽象类
class Father {
public:
    virtual void show() = 0;      // 纯虚函数1
    virtual void introduce() = 0; // 纯虚函数2
    
    void FatherFunction() {       // 普通函数
        cout << "父类函数" << endl;
    }
};

// 子类1 - 实现了所有纯虚函数 ✅
class Child : public Father {
public:
    void show() {  // 必须实现
        cout << "Child的show" << endl;
    }
    
    void introduce() {  // 必须实现
        cout << "Child的introduce" << endl;
    }
};

// 子类2 - 没有实现所有纯虚函数 ❌
class Child2 : public Father {
public:
    void show() {  // 只实现了一个
        cout << "Child2的show" << endl;
    }
    // 没有实现introduce()
};

// 测试
Child c;    // ✅ 可以，Child实现了所有纯虚函数
Child2 c2;  // ❌ 错误！Child2还是抽象类
```

### 4.总结

**纯虚函数**

- ✅ 语法：`virtual void func() = 0;`
- ✅ 父类不实现
- ✅ 强制子类实现
- ✅ 定义接口规范

**抽象类**

- ✅ 有至少一个纯虚函数
- ❌ 不能实例化
- ✅ 只能做父类
- ✅ 可以有普通函数和成员变量

**子类约束**

- ✅ 必须实现所有纯虚函数
- ❌ 否则子类也是抽象类
- ✅ 全部实现后才能实例化



## 四、虚析构函数

### 1.先总结：

**只要类有虚函数，析构函数就应该是虚函数！**

**为什么？**

- 有虚函数 → 这个类设计用来做父类
- 做父类 → 可能会用父类指针指向子类对象
- 父类指针delete → 需要虚析构保证正确释放资源

```c++
class Father {
public:
    virtual void show() = 0;  // 有虚函数
    virtual ~Father() {}      // 析构也要virtual！
};
```



### 2.问题场景

先看一个有问题的代码

```c++
class Father {
public:
    Father() {
        cout << "Father构造" << endl;
    }
    
    ~Father() {  // 普通析构函数（没有virtual）
        cout << "Father析构" << endl;
    }
};

class Child : public Father {
private:
    int* data;  // 子类有动态分配的内存
public:
    Child() {
        data = new int[100];  // 分配内存
        cout << "Child构造" << endl;
    }
    
    ~Child() {
        delete[] data;  // 释放内存
        cout << "Child析构" << endl;
    }
};

// 测试
int main() {
    Father* p = new Child();  // 父类指针指向子类对象
    delete p;  // 删除对象
    
    return 0;
}
```

#### 输出结果：

```
Father构造
Child构造
Father析构    ← 只调用了Father的析构！
```

#### 问题：

- **Child的析构函数没有被调用！**
- `delete[] data;` 没有执行
- **内存泄漏了！** 100个int的内存没有释放

### 3.原因分析

#### 为什么只调用Father的析构？

```c++
Father* p = new Child();
delete p;
```

- `p` 的类型是 `Father*`
- 析构函数不是`virtual`
- **静态绑定** - 编译器看指针类型，只调用 `Father::~Father()`
- `Child::~Child()` 没有被调用

### 4.解决方案：虚析构函数

把Father的析构函数改成virtual

```c++
class Father {
public:
    Father() {
        cout << "Father构造" << endl;
    }
    
    virtual ~Father() {  // 加上virtual
        cout << "Father析构" << endl;
    }
};

class Child : public Father {
private:
    int* data;
public:
    Child() {
        data = new int[100];
        cout << "Child构造" << endl;
    }
    
    ~Child() {  // 可以不写virtual，但建议写
        delete[] data;
        cout << "Child析构" << endl;
    }
};

// 测试
int main() {
    Father* p = new Child();
    delete p;
    
    return 0;
}
```

#### 输出结果：

```
Father构造
Child构造
Child析构     ← Child的析构被调用了！
Father析构    ← 然后调用Father的析构
```

 正确了！

- 先调用 `Child::~Child()` - 释放了data的内存
- 再调用 `Father::~Father()` - 释放父类资源
- **没有内存泄漏！**

#### 析构顺序：

构造顺序：父 → 子

```
Father构造
Child构造
```

析构顺序：子 → 父（相反）

```
Child析构
Father析构
```

**记忆**: 先穿衣服后穿外套，先脱外套后脱衣服





### 5.什么时候需要虚析构？

#### 必须用虚析构的情况：

1. **类会被继承**
2. **会用父类指针指向子类对象**
3. **会通过父类指针delete对象**

```c++
Father* p = new Child();
delete p;  // 如果析构不是virtual，会内存泄漏
```



#### 不需要虚析构的情况：

1. **类不会被继承**（final类）
2. **不会用父类指针delete**

```c++
Child* p = new Child();
delete p;  // 直接用子类指针，不需要虚析构
```





