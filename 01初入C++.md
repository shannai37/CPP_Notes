C++在保留C语言特性的基础上增加了很多新特性。



## C++与C的基本区别

### 1. 输入输出方式

C++引入了更方便的iostream库：

```c++
// C语言方式
#include <stdio.h>
printf("HelloWorld，%d\n", num);
scanf("%d", &num);

// C++方式
#include <iostream>
using namespace std;
cout << "HelloWorld，" << num << endl;
cin >> num;
```

### 2. 命名空间（namespace）

用于避免命名冲突：

```cpp
#include <iostream>
using namespace std;  // 使用标准命名空间

// 或者不用using，每次都加std::
std::cout << "Hello" << std::endl;
```



### 3. 引用（Reference）

C++新增的类型，是变量的别名：
由于是别人的“别名”，所以**取别名时必须要有初始化**

```c++
int a = 10;
int& ref = a;  // ref是a的引用
ref = 20;      // 修改ref就是修改a
```

#### 引用传参

```c++

// 引用传参 
void func_ref(int &x)
{
	x++; 
	cout << "函数内的值"<< x << endl; 
} 

int main(int argc, char** argv) 
{
	int a = 10;
	int& ref = a;  // ref是a的引用
	ref = 20;      // 修改ref就是修改a	
	
	func_ref(ref);
	
	cout << "函数外的值"<< ref << endl;
}
```



### 4. 函数重载（Function Overloading）

允许同名函数有不同的参数：

```c++
int add(int a, int b) { return a + b; }
double add(double a, double b) { return a + b; }
int add(int a, int b, int c) { return a + b + c; }
```

### 5. 默认参数

```c++
void print(int a, int b = 10, int c = 20) {
    cout << a << " " << b << " " << c << endl;
}

print(1);        // 输出: 1 10 20
print(1, 2);     // 输出: 1 2 20
print(1, 2, 3);  // 输出: 1 2 3
```



## 面向对象编程

### 6. 类和对象（Class & Object）

这是C++最核心的特性：

```c++
class Student {
private:
    string name;
    int age;
    
public:
    // 构造函数
    Student(string n, int a) {
        name = n;
        age = a;
    }
    
    // 成员函数
    void display() {
        cout << "姓名: " << name << ", 年龄: " << age << endl;
    }
    
    // getter和setter
    void setAge(int a) { age = a; }
    int getAge() { return age; }
};

// 使用
Student s1("张三", 20);
s1.display();
```



### 7. 访问控制

- public：公开的，任何地方都能访问

- private：私有的，只能在类内部访问

- protected：保护的，类内部和子类可以访问

### 8. 构造函数和析构函数

```c++
class MyClass {
public:
    MyClass() {  // 构造函数：创建对象时调用
        cout << "对象被创建" << endl;
    }
    
    ~MyClass() {  // 析构函数：销毁对象时调用
        cout << "对象被销毁" << endl;
    }
};
```



### 9. 动态内存分配

```c++
// C语言方式
int* p = (int*)malloc(sizeof(int));
free(p);

// C++方式
int* p = new int;        // 分配单个变量
delete p;

int* arr = new int[10];  // 分配数组
delete[] arr;
```



### 10.bool类型

```c++
bool flag = true;   // C++内置bool类型
if (flag) {
    // ...
}
```



## 不同的内存开辟方式

### 内存分区回顾

1.栈区

```c++
#include <iostream>
using namespace std;

// ============================================
// C++内存分区模型（四区）
// ============================================

// 3. 全局/静态存储区（Global/Static Area）
// - 包含全局变量、静态变量、常量数据
int global_var = 100;              // 全局变量（已初始化）
static int static_var = 200;       // 静态变量（已初始化）
const int const_var = 300;         // 全局常量
const char* str = "hello";         // 字符串字面量

// 4. 代码区（Code/Text Segment）
// - 存放函数体的二进制代码（只读）
void func() {
    // 1. 栈区（Stack）- 自动管理
    // - 存放局部变量、函数参数、返回地址
    // - 特点：自动分配和释放，空间有限（一般1-2MB）
    int a = 10;              // 局部变量，栈区
    int arr[100];            // 局部数组，栈区
    
    // 2. 堆区（Heap）- 手动管理
    // - 动态分配的内存
    // - 特点：程序员手动分配和释放，空间大，速度较慢
    int* p = new int(20);         // 堆区分配，p在栈区，*p在堆区
    int* arr2 = new int[100];     // 堆区分配数组
    
    cout << "栈区变量 a: " << a << endl;
    cout << "堆区变量 *p: " << *p << endl;
    
    // 必须手动释放堆内存！
    delete p;
    delete[] arr2;
    
}  // 函数结束，栈区变量自动释放

int main() {
    cout << "=== C++内存四区模型 ===" << endl;
    cout << "\n1. 代码区（Code）：存放程序的机器码" << endl;
    cout << "2. 全局/静态区（Global/Static）：全局变量、静态变量、常量" << endl;
    cout << "3. 栈区（Stack）：局部变量、函数参数" << endl;
    cout << "4. 堆区（Heap）：new/malloc动态分配的内存" << endl;
    
    cout << "\n=== 地址验证 ===" << endl;
    cout << "全局变量地址: " << &global_var << endl;
    cout << "字符串常量地址: " << (void*)str << endl;
    
    int local = 1;
    int* heap = new int(2);
    cout << "栈区变量地址: " << &local << endl;
    cout << "堆区变量地址: " << heap << endl;
    
    delete heap;
    
    func();
    
    return 0;
}
```

