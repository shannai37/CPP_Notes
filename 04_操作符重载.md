# C++ 操作符重载 - 技术笔记

## 一、输出运算符 <<

### 实现方式
必须使用友元函数，不能用成员函数。

### 标准写法
```cpp
class Point {
private:
    int x, y;
public:
    Point(int px, int py) {
        x = px;
        y = py;
    }
    
    // 类内声明
    friend ostream& operator<<(ostream &out, const Point &p);
};

// 类外定义
// const Point &p：const表示不修改参数p
ostream& operator<<(ostream &out, const Point &p) {
    out << "(" << p.x << ", " << p.y << ")";
    return out;  // 返回流引用，支持链式调用
}
```

### 使用
```cpp
Point p(10, 20);
cout << p << endl;           // 输出：(10, 20)
cout << p << " " << p;       // 链式调用
```

### 关键点
- 第一个参数：`ostream &out`
- 第二个参数：`const 类名 &obj`
- 返回类型：`ostream&`
- 必须返回out以支持链式调用

---

## 二、前置++运算符

### 标准写法
```cpp
class Counter {
private:
    int count;
public:
    Counter(int c = 0) {
        count = c;
    }
    
    // 前置++：无参数，返回引用
    Counter& operator++() {
        ++count;        // 先自增
        return *this;   // 返回自身引用
    }
    
    int getCount() const {  // const：表示不修改对象
        return count;
    }
};
```

### 特点
- 无参数
- 返回引用 `类名&`
- 先自增，再返回
- 返回自身 `*this`

### 使用
```cpp
Counter c(5);
++c;              // count变为6
Counter c2 = ++c; // count变为7，c2也是7
```

---

## 三、后置++运算符

### 标准写法
```cpp
class Counter {
private:
    int count;
public:
    Counter(int c = 0) {
        count = c;
    }
    
    // 后置++：有int参数，返回值
    Counter operator++(int) {
        Counter temp(*this);  // 保存当前值（*this表示当前对象）
        ++count;              // 自增
        return temp;          // 返回旧值
    }
    
    int getCount() const {
        return count;
    }
};
```

### 特点
- 有int参数（占位符，不使用）
- 返回值 `类名`（不是引用）
- 先保存旧值，再自增，最后返回旧值
- 需要临时对象

### 使用
```cpp
Counter c(5);
c++;              // count变为6
Counter c2 = c++; // c的count变为7，c2是6（旧值）
```

---

## 四、前置++与后置++对比

| 特性 | 前置++（++obj） | 后置++（obj++） |
|------|----------------|----------------|
| 语法 | `operator++()` | `operator++(int)` |
| 参数 | 无 | int（占位符） |
| 返回类型 | 引用 `类名&` | 值 `类名` |
| 执行顺序 | 先增后返回 | 先保存，增，返回旧值 |
| 返回内容 | 自身引用 | 旧值副本 |
| 效率 | 高 | 低（需临时对象） |

---

## 五、加法运算符 +

### 标准写法（成员函数）
```cpp
class Point {
private:
    int x, y;
public:
    Point(int px = 0, int py = 0) {
        x = px;
        y = py;
    }
    
    // const Point &p：const表示不修改参数p
    // 函数后的const：表示不修改当前对象
    Point operator+(const Point &p) const {
        Point temp;
        temp.x = x + p.x;
        temp.y = y + p.y;
        return temp;
    }
};
```

### 调用方式
```cpp
Point p1(1, 2);
Point p2(3, 4);
Point p3 = p1 + p2;  // 等价于 p1.operator+(p2)
```

### 关键点
- 参数：`const 类名 &`
- 函数：`const`修饰
- 返回：新对象（值），不是引用
- 不修改原对象

---

## 六、赋值运算符 =

### 标准写法
```cpp
class String {
private:
    char *str;
    int len;
public:
    // const String &s：const表示不修改参数s
    String& operator=(const String &s) {
        if (this == &s) return *this;  // 防止自我赋值
        
        delete[] str;  // 释放旧内存
        
        len = s.len;
        str = new char[len + 1];
        strcpy(str, s.str);
        
        return *this;  // 返回自身引用，支持连续赋值 a=b=c
    }
};
```

### 关键步骤
1. 检查自我赋值
2. 释放旧资源
3. 分配新资源
4. 返回 `*this`

---

## 七、关系运算符 ==, !=

### 标准写法
```cpp
class Point {
private:
    int x, y;
public:
    // const：不修改当前对象
    bool operator==(const Point &p) const {
        return x == p.x && y == p.y;
    }
    
    bool operator!=(const Point &p) const {
        return !(*this == p);  // 复用==的逻辑
    }
};
```

---

## 八、下标运算符 []

### 标准写法
```cpp
class Array {
private:
    int *data;
    int size;
public:
    // 非const版本（可读写）
    int& operator[](int index) {
        return data[index];
    }
    
    // const版本（只读）
    // 函数后的const：表示不修改对象
    const int& operator[](int index) const {
        return data[index];
    }
};
```

### 使用
```cpp
Array arr(10);
arr[0] = 100;        // 调用非const版本
cout << arr[0];      // 调用非const版本

const Array arr2(10);
cout << arr2[0];     // 调用const版本
```

---

## 九、实现方式总结

### 成员函数实现
```cpp
class T {
    T operator+(const T &obj) const;      // 算术运算符
    T& operator+=(const T &obj);          // 复合赋值
    bool operator==(const T &obj) const;  // 关系运算符
    T& operator++();                      // 前置++
    T operator++(int);                    // 后置++
    T& operator[](int);                   // 下标运算符
};
```

### 友元函数实现
```cpp
class T {
    friend ostream& operator<<(ostream &out, const T &obj);  // 输出
    friend istream& operator>>(istream &in, T &obj);         // 输入
    friend T operator+(const T &a, const T &b);              // 算术（可选）
};
```

---

## 十、const使用说明

### 参数前的const
```cpp
void func(const Point &p)  // const表示不修改参数p
```
- 提高效率（避免拷贝）
- 保证安全（不会误修改）

### 函数后的const
```cpp
int getValue() const  // const表示不修改对象的成员变量
```
- 只读函数
- 可以被const对象调用

---

## 十一、返回类型选择

| 返回内容 | 返回类型 | 示例 |
|---------|---------|------|
| 自身/已存在对象 | 引用 | `T&` | `operator++()` |
| 新创建的对象 | 值 | `T` | `operator+(const T&)` |
| 局部/临时对象 | 值 | `T` | `operator++(int)` |
| 流对象 | 流引用 | `ostream&` | `operator<<` |

**重要**：绝不返回局部变量的引用！

---

## 十二、常用运算符速查

| 运算符 | 实现方式 | 返回类型 | 参数 | 注意事项 |
|--------|---------|---------|------|---------|
| `<<` | 友元 | `ostream&` | `(ostream&, const T&)` | 必须友元 |
| `>>` | 友元 | `istream&` | `(istream&, T&)` | 必须友元 |
| `+` | 成员/友元 | `T` | `(const T&)` | const函数 |
| `+=` | 成员 | `T&` | `(const T&)` | 返回*this |
| `==` | 成员/友元 | `bool` | `(const T&)` | const函数 |
| `++`前 | 成员 | `T&` | 无 | 返回*this |
| `++`后 | 成员 | `T` | `(int)` | int占位符 |
| `[]` | 成员 | `T&` | `(int)` | 两个版本 |
| `=` | 成员 | `T&` | `(const T&)` | 检查自赋值 |

---

## 十三、不能重载的运算符

- `.` （成员访问）
- `.*` （成员指针访问）
- `::` （作用域解析）
- `?:` （三目运算符）
- `sizeof`
- `typeid`

