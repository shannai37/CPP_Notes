# C++ 模版笔记

> 写一次代码，适用多种类型！

---

## 一、什么是模版？

**模版就像一个"万能模具"** —— 同一个模具可以制造不同材料的产品。

### 为什么需要模版？

没有模版时，写一个比较大小的函数：
- 比较 int → 写一个函数
- 比较 double → 再写一个函数  
- 比较 char → 又要再写一个函数

**代码重复太多！**

**有了模版**：写一次代码，自动适配所有类型 ✅

---

## 二、模版的分类

| 类型 | 说明 | 例子 |
|------|------|------|
| **函数模版** | 定义一个函数框架，类型可变 | 求最大值、交换变量 |
| **类模版** | 定义一个类框架，类型可变 | `vector<T>`、`stack<T>` |

---

## 三、函数模版入门

### 基础语法

```cpp
template <typename T>  // 声明模版，T是类型参数
T getMax(T a, T b) {   // T可以是任何类型
    return (a > b) ? a : b;
}
```

### 完整例子：求最大值

```cpp
#include <iostream>
using namespace std;

// 函数模版
template <typename T>
T getMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    // 自动推导类型
    cout << getMax(10, 20) << endl;        // int类型，输出: 20
    cout << getMax(3.5, 2.8) << endl;      // double类型，输出: 3.5
    cout << getMax('A', 'Z') << endl;      // char类型，输出: Z
    
    return 0;
}
```

**关键点**：
- `template <typename T>` - 声明模版
- `T` - 类型参数（习惯用T，是Type的缩写）
- 编译器自动推导类型，不需要手动指定

---

## 四、类模版入门

### 基础语法

```cpp
template <typename T>
class Stack {
private:
    T data[100];  // T可以是任何类型
    int top;
public:
    void push(T value);
    T pop();
};
```

### 完整例子：简单的栈

```cpp
#include <iostream>
using namespace std;

// 类模版
template <typename T>
class Stack {
private:
    T data[100];
    int top;
public:
    Stack() : top(-1) {}
    
    void push(T value) {
        data[++top] = value;
    }
    
    T pop() {
        return data[top--];
    }
};

int main() {
    // 使用时必须指定类型
    Stack<int> intStack;      // 整数栈
    intStack.push(10);
    intStack.push(20);
    cout << intStack.pop() << endl;  // 输出: 20
    
    Stack<string> strStack;   // 字符串栈
    strStack.push("Hello");
    strStack.push("World");
    cout << strStack.pop() << endl;  // 输出: World
    
    return 0;
}
```

**关键点**：
- 使用类模版时，必须用 `<>` 指定类型
- `Stack<int>` 和 `Stack<string>` 是两个完全不同的类
- 一个模版，可以生成无数种类型的类

---

## 五、术语辨析（容易混淆）

### 核心理解：模版 vs 实例

**"模版"是蓝图，"实例"是成品**

### 函数相关

| 术语 | 含义 | 谁写的 | 例子 |
|------|------|--------|------|
| **函数模版** | 你写的代码框架（蓝图） | 你写的 | `template<typename T> void mySwap(T &a, T &b)` |
| **模版函数** | 编译器生成的具体函数（成品） | 编译器生成 | `mySwap<int>`、`mySwap<double>` |

### 类相关

| 术语 | 含义 | 谁写的 | 例子 |
|------|------|--------|------|
| **类模版** | 你写的类框架（蓝图） | 你写的 | `template<typename T> class Stack` |
| **模版类** | 编译器生成的具体类（成品） | 编译器生成 | `Stack<int>`、`Stack<string>` |

### 直观例子

```cpp
// 函数模版（你写的1个蓝图）
template <typename T>
void mySwap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 1, y = 2;
    mySwap(x, y);        // 编译器生成 mySwap<int> 模版函数
    
    double m = 1.1, n = 2.2;
    mySwap(m, n);        // 编译器生成 mySwap<double> 模版函数
    
    // 1个函数模版 → 生成了2个模版函数
}
```

**简单记忆**：
- **模版在前** = 蓝图（你写的）
- **模版在后** = 成品（编译器生成的）

---

## 六、实际应用：STL容器

STL（标准模版库）全是模版写的！

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <map>
using namespace std;

int main() {
    // vector是类模版，vector<int>是模版类
    vector<int> v = {1, 2, 3};
    cout << v[0] << endl;  // 输出: 1
    
    // stack是类模版，stack<double>是模版类
    stack<double> s;
    s.push(3.14);
    cout << s.top() << endl;  // 输出: 3.14
    
    // map是类模版，map<string, int>是模版类
    map<string, int> ages;
    ages["Tom"] = 20;
    cout << ages["Tom"] << endl;  // 输出: 20
    
    return 0;
}
```

**你每天都在用别人写好的模版！**

---

## 七、模版的优缺点

###  优点

| 优点 | 说明 |
|------|------|
| 代码复用 | 写一次，用N次 |
| 类型安全 | 编译期检查错误 |
| 高效 | 无运行时开销 |

### 缺点

| 缺点 | 说明 |
|------|------|
| 编译时间长 | 每种类型都要生成代码 |
| 错误信息复杂 | 报错信息难读 |
| 代码膨胀 | 生成的二进制文件变大 |

---

## 八、常见关键字

| 关键字 | 含义 | 备注 |
|--------|------|------|
| `template` | 声明这是一个模版 | 必须写 |
| `typename` | 表示类型参数 | 也可以用 `class` |
| `T` | 习惯的类型参数名 | Type的缩写，也可用其他名字 |

---

## 九、学习建议

### 必须掌握（会用就行）

1. 看懂 `template <typename T>` 是什么意思
2. 会使用STL容器：`vector<int>`、`stack<double>` 等
3. 能写一个最简单的函数模版或类模版
4. 理解模版是为了代码复用

### 了解即可

1. 函数模版 vs 模版函数的术语区别
2. 类模版 vs 模版类的术语区别
3. 知道模版是编译时生成代码

### 不用深究（以后再学）

1. 模版特化、偏特化
2. 可变参数模版
3. 模版元编程

---

## 十、完整示例：配对类

```cpp
#include <iostream>
using namespace std;

// 类模版：可以存储任意两种类型的配对
template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;
    
    Pair(T1 f, T2 s) : first(f), second(s) {}
    
    void print() {
        cout << "(" << first << ", " << second << ")" << endl;
    }
};

int main() {
    // 姓名-年龄配对
    Pair<string, int> p1("Alice", 20);
    p1.print();  // 输出: (Alice, 20)
    
    // 坐标配对
    Pair<double, double> p2(3.5, 2.8);
    p2.print();  // 输出: (3.5, 2.8)
    
    // 成绩配对
    Pair<char, double> p3('A', 98.5);
    p3.print();  // 输出: (A, 98.5)
    
    return 0;
}
```

**一个类模版，创建出不同用途的类！**

---

## 十一、核心总结

### 一句话理解模版

> **模版 = 类型参数化 = 把类型当作参数传递**

### 记忆口诀

```
函数模版和类模版，是你写的蓝图（带template关键字）
模版函数和模版类，是编译器生成的成品（如Stack<int>）

写一次代码，生成N个版本
这就是模版的魔法！✨
```

### 工作中的实际情况

- **作为使用者（90%）**：天天用STL，不用自己写模版
- **作为编写者（10%）**：只有写库、框架时才写模版

### 考试重点

1. 会写简单的函数模版（如求最大值、交换变量）
2. 会写简单的类模版（如Stack、Array）
3. 会使用STL容器（vector、stack、map等）
4. 能说出模版的优缺点

---

## 十二、快速参考

### 函数模版模板

```cpp
template <typename T>
T functionName(T param1, T param2) {
    // 函数体
}
```

### 类模版模板

```cpp
template <typename T>
class ClassName {
private:
    T member;
public:
    void method(T param);
};
```

### 使用方式

```cpp
// 函数模版：自动推导
functionName(10, 20);

// 类模版：必须指定
ClassName<int> obj;
```

