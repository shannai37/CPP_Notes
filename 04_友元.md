# C++ 友元 - 技术笔记

## 一、友元概念

**友元（Friend）**：允许外部函数或类访问当前类的私有成员。

### 访问权限
- `public`：任何地方可访问
- `private`：只有类内部和友元可访问
- `protected`：类内部、子类和友元可访问

---

## 二、友元函数

### 基本语法
```cpp
class Box {
private:
    int width;
    int height;
public:
    Box(int w, int h) {
        width = w;
        height = h;
    }
    
    // 类内声明：用friend关键字
    friend void printBox(Box &b);
};

// 类外定义：不需要friend关键字，不需要::
// const Box &b：const表示不修改参数b
void printBox(const Box &b) {
    // 可以直接访问私有成员
    cout << "宽度: " << b.width << endl;
    cout << "高度: " << b.height << endl;
}
```

### 关键点
1. 在类内用 `friend` 声明
2. 在类外定义时不需要 `friend` 和 `::`
3. 不是类的成员函数
4. 可以访问类的私有和保护成员
5. 声明位置（public/private/protected）不影响效果

---

## 三、友元函数：引用 vs 指针

### 引用方式（推荐）
```cpp
friend void function1(Box &b);

void function1(Box &b) {
    cout << b.width << endl;  // 用点号访问
}

// 调用
Box box(10, 20);
function1(box);  // 直接传对象
```

### 指针方式
```cpp
friend void function2(Box *p);

void function2(Box *p) {
    cout << p->width << endl;  // 用箭头访问
}

// 调用
Box box(10, 20);
function2(&box);  // 传地址
```

---

## 四、友元类

### 基本语法
```cpp
class TV {
private:
    int channel;
    int volume;
public:
    TV() {
        channel = 1;
        volume = 10;
    }
    
    // 声明Remote类为友元类
    friend class Remote;
};

class Remote {
public:
    void changeChannel(TV &tv, int ch) {
        tv.channel = ch;  // 可以访问TV的私有成员
    }
    
    void changeVolume(TV &tv, int vol) {
        tv.volume = vol;
    }
};
```

### 特点
- 友元类的所有成员函数都可以访问目标类的私有成员
- 友元关系是**单向的**（A是B的友元，B不是A的友元）
- 友元关系**不能传递**（A是B的友元，B是C的友元，A不是C的友元）
- 友元关系**不能继承**

---

## 五、友元成员函数

### 基本语法
```cpp
class TV;  // 前向声明

class Remote {
public:
    void changeChannel(TV &tv, int ch);  // 只声明
};

class TV {
private:
    int channel;
public:
    TV() {
        channel = 1;
    }
    
    // 只让Remote的changeChannel函数成为友元
    friend void Remote::changeChannel(TV &tv, int ch);
};

void Remote::changeChannel(TV &tv, int ch) {
    tv.channel = ch;  // 可以访问TV的私有成员
}
```

---

## 六、友元的主要应用场景

### 1. 重载输出运算符 <<
```cpp
class Point {
private:
    int x, y;
public:
    Point(int px, int py) {
        x = px;
        y = py;
    }
    
    // 必须是友元函数
    friend ostream& operator<<(ostream &out, const Point &p);
};

// const Point &p：const表示不修改参数p
ostream& operator<<(ostream &out, const Point &p) {
    out << "(" << p.x << ", " << p.y << ")";
    return out;
}
```

**原因**：`cout << p` 相当于 `operator<<(cout, p)`，第一个参数是ostream，无法作为成员函数。

### 2. 双目运算符（可选友元函数实现）
```cpp
class Complex {
private:
    double real, imag;
public:
    // 友元函数版本
    friend Complex operator+(const Complex &a, const Complex &b);
};

// const表示不修改参数a和b
Complex operator+(const Complex &a, const Complex &b) {
    Complex temp;
    temp.real = a.real + b.real;
    temp.imag = a.imag + b.imag;
    return temp;
}
```

**优势**：更灵活，可以实现 `5 + 对象` 这样的操作。

---

## 七、友元 vs 成员函数 vs 普通函数

| 特性 | 普通函数 | 成员函数 | 友元函数 |
|------|---------|---------|---------|
| 访问私有成员 | ❌ | ✅ | ✅ |
| 是类的成员 | ❌ | ✅ | ❌ |
| 需要对象调用 | ❌ | ✅ | ❌ |
| 可以访问this | ❌ | ✅ | ❌ |
| 在类内声明 | ❌ | ✅ | ✅ |
| 在类外定义需要:: | ❌ | ✅ | ❌ |

---

## 八、友元的注意事项

### 破坏封装性
- 友元会破坏类的封装性
- 应该慎用，只在必要时使用
- 常见必要场景：运算符重载（特别是 `<<` 和 `>>`）

### 声明位置
```cpp
class Test {
private:
    int data;
    friend void func();  // ✅ 可以在private中声明
public:
    friend void func2(); // ✅ 也可以在public中声明
};
```
效果相同，位置不影响。

### 不能是虚函数
友元函数不是成员函数，不能是虚函数。

---

## 九、实际示例

### 示例1：基础友元函数
```cpp
class Student {
private:
    string name;
    int age;
    double score;
public:
    Student(string n, int a, double s) {
        name = n;
        age = a;
        score = s;
    }
    
    // const Student &stu：const表示不修改参数stu
    friend void printStudent(const Student &stu);
    friend void updateScore(Student &stu, double newScore);
};

void printStudent(const Student &stu) {
    cout << "姓名: " << stu.name << endl;
    cout << "年龄: " << stu.age << endl;
    cout << "成绩: " << stu.score << endl;
}

void updateScore(Student &stu, double newScore) {
    stu.score = newScore;  // 可以修改私有成员
}
```

### 示例2：友元类
```cpp
class TV {
private:
    string brand;
    int channel;
    int volume;
    bool isOn;
public:
    TV(string b) {
        brand = b;
        channel = 1;
        volume = 10;
        isOn = false;
    }
    
    friend class Remote;  // Remote是TV的友元类
    
    // const：表示这个函数不修改对象
    void showStatus() const {
        cout << "品牌: " << brand << endl;
        cout << "电源: " << (isOn ? "开" : "关") << endl;
        if (isOn) {
            cout << "频道: " << channel << endl;
            cout << "音量: " << volume << endl;
        }
    }
};

class Remote {
public:
    void turnOn(TV &tv) {
        tv.isOn = true;  // 访问TV的私有成员
    }
    
    void changeChannel(TV &tv, int ch) {
        if (tv.isOn) {
            tv.channel = ch;
        }
    }
};
```

---

## 十、友元总结

### 何时使用友元
1. 重载输出运算符 `<<` 和输入运算符 `>>`（必须使用）
2. 某些运算符需要左右操作数对称性（可选使用）
3. 外部函数需要频繁访问多个私有成员（慎用）

### 基本原则
- 能用成员函数就用成员函数
- 只在必要时使用友元
- 不要滥用，避免破坏封装性

### 标准模板
```cpp
class 类名 {
private:
    数据成员;
public:
    // 友元函数声明
    friend 返回类型 函数名(参数列表);
    
    // 友元类声明
    friend class 类名;
};

// 友元函数定义（类外）
返回类型 函数名(参数列表) {
    // 可以访问私有成员
}
```

